<!-- TOC -->autoauto- [之前忘记写了,直接从当前阶段写起](#之前忘记写了直接从当前阶段写起)auto    - [正式记录](#正式记录)autoauto<!-- /TOC -->
# 之前忘记写了,直接从当前阶段写起

目前已完成:基本界面布局,获取文章基本信息以及分页  

简要说一下过程  

1. 用nuxt配合vuetify搭建项目,主题配色啥的看个人喜好,在`nuxt.config.js`里面可以调

2. 用`card`组件展示文章基本信息,`pagination`分页,后台实现了分页查询功能就直接设置参数(currentPage,pageSize...)请求,然后修改当前的页面数据即可，非常简单

目前就做到这里,后面再记录更完整的过程

## 正式记录

1. marked.js不要用npm下载,用cdn引入,否则无法正确识别代码，cdn引入的文件再mounted之后才能识别到，所以之前一定不要引用cdn的变量,markedjs配合highligh.js解析后端返回的markdown数据,然后用`<div v-html="data">`把数据丢进去即可。

2. 文章目录实现,前端重写markedjs中renderer的解析函数,参考[官方文档](https://marked.js.org/#/USING_PRO.md#renderer),解析函数中把`<h1>xxx</h1>`等替换成`<h1 id=xxx> xxx </h1>`,然后实现跳转,路径为当前路径加上`#xxx`这里的`xxx`就是前面的id,实际上就是标题的名字。我自己是单独做成了一个抽屉,然后用`vuetify`的`$vuetify.goTo`函数实现跳转(也可以直接做路径跳转，只是动画效果不太好.实现代码在`pages/index.vue`(解析)和`layout/default.vue`(抽屉)

3. 跳转是使用nuxt的动态路由,略过。

4. 右下角的按钮是参考vuetify官方的v-scroll配合悬浮按钮实现的,`v-scroll`可以绑定回调函数,默认在窗口滚动的时候触发,函数中可以打印当前位置,根据这个决定是否显示按钮.实现代码位置为`layout/default.vue`

5. 日期查询,类型查询和统计合成一个card组件,通过`emit`和`on`传递消息,注意这俩不能跨辈分传消息,比如孙子不能直接emit爷爷的方法,只能一层一层emit上去获取用vuex传递消息.

6. 点击屏幕关闭抽屉以及左右滑动打开抽屉,使用`v-touch`捕捉手势动作,需要把`nuxt.config.js`中`vuetify`的`treeShake`关掉.这玩意儿是打包的时候按需加载用的,nuxt内置的这个loader现在有bug,打开了的话`v-touch`在production环境下会失效,就是没加载进去,看看啥时候能修复把。

7. 重写2.中提及的renderer解析函数,对图片进行解析,同时调整表情的大小,renderer配置代码如下

``` js
        //基本配置与代码高亮配置
        const renderer = new marked.Renderer();
        //重写renderer,把id加上,注意id要换成anchor_开头,同时替换内部非法字符,防止因为非法字符引起的vuetify调用selector报错
        renderer.heading = function (text, level) {
            const escapedText = text.replace(/\//g, '_');
            return `
                    <h${level} id="anchor_${escapedText}">
                        ${text}
                    </h${level}>`;
        };
        let width = this.emoji_width
        renderer.image = function (href,title,text) {
            let token = href.split('/')
            let name = token[token.length-1]
            let reg = /emoji-/
            if(reg.test(name)){
                return `<img src="${href}" width=${width} >`
            }else{
                return `
                    <img src="${href}">
                    `;
            }
```

## 2020/3/8

markdown改用 prism.js高亮，因为highlight有些语法不知道为啥不能识别,使用prism的步骤:  

1.cdn引入prism.js和css文件

2.在文章页面:  

``` js
    mounted(){
        this.$nextTick(()=>{
            Prism.highlightAll()

        })
    }
```  

3.删除marked配置中的highlight配置，直接返回code  

``` js
    marked.setOptions({
        renderer: renderer,
        pedantic: false,
        gfm: true,
        tables: true,
        breaks: false,
        sanitize: false,
        smartLists: true,
        smartypants: false,
        xhtml: false,
        highlight: function (code) {
            return code;
        }
    });
```

注意所有cdn引入的变量都要在mouted或之后使用，之前是没有引入的,仅限nuxt,有很多这种ssr渲染导致的坑...  

然后使用李笑来的css样式排版,[链接](https://www.jianshu.com/p/32b7d963febf),非常好看  

4.使用IntersectionObserver判断阅读到了文章的哪个位置，对应目录位置激活。逻辑为:在文章页面created时候获取每一个标题对应的element(DOM建立之后才有),然后new 一个IntersectionObserver监视,当标题元素出现在屏幕中，回调函数中修改目录列表中激活的目录即可。

5.在导航条(app-bar)中添加“关于”，“其他”，“首页”按钮,当屏幕为移动设备时收至左侧抽屉,左侧抽屉设置为移动端才显示
